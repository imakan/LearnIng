# 问业界常见的GC方式有哪些

先解释QPS,(单位时间内所能处理的并发数)：比如我们8点上班，不考虑员工迟到的情况下，极限qps是，7点半到8点打卡，公司员工有1000人，平均每个员工到登录系统的时间为5分钟，那么

QPS是 1000/30*60

并发数是  QPS * 5*60

> 常见的垃圾回收算法是：引用计数，标记清楚，标记收集，标记整理

## 引用计数

顾名思义，引用计数就是为每一个对象都定义一个计数器，当某一个对象没有被其他的对象引用时，我们称作这个对象是零引用，也就是这个对象是被为一个垃圾。

### 引用计数的优缺点

优点：
+ 内存释放比较及时，以为当一个对象的计数为0时，立马会被释放
+ 延时性低，因为这个释放时间会被均匀到每个阶段

缺点：

+ 为每个对象都要创建一个计数器，而且没对象的销毁和创建都会有一个比较昂贵的原子操作和空间
+ 无法处理循环引用

还有一种场景就是如果一个大对象的计数为0的话，会造成一大批的对象会被清除，这种场景很常见，清除操作会在执行栈上去完成，所以会造成额外的空间和资源


## 标记清除

顾名思义标记清除分为两个阶段，标记和清除，当GC被触发时，它会从js的全局对象开始，标记它所能达到的对象，一般采用DFS操作，然后清除没有标记的对象

优点：

+ 解决了引用计数不能解决的循环引用

缺点：

+ 要为每个对象开辟一个引用标记字段空间
+ 因为采用深度优先搜索，所以DFS效率和未标记的对象大小有关，当对非常大的时候，这个垃圾回收算法性能比较不好


## 标记复制

标记复制其实就是在堆中我们要开辟两个空间，记录一个使用状态，记录一个空闲状态，当GC时，会检查使用状态的内存块，将活着的对象复制到空闲状态的内存，然后交换两个内存空间。

缺点：
+ 涉及到复制的操作，所以内存大量的空间，而且我们维护了两个内存块最终只使用到了其中一个

## 标记整理

标记整理就是在整理内存过程中，将活着的对象往一端移动，移动完成后，会清理边界外的内存

说到这里要说明一下V8的内存管理和GC算法

在V8中内存分为两类。一个是新生代，一个是老生代，
新生代主要管理一些小对象且存活时间比较短的。老生代主要管理一些大对象，存活时间比较长的。

新生代采用是scavenge算法主要实现了cheney：

这里要讲下nodejs中的默认值是64M,因为采用了scavenge，他将内存分为两块，一块我们成为From空间，一个我们成为To空间，新对象都会被分配到From空间，如果From空间快要被占满了，那么将存活的对象分配到To空间，然后清空From空间，此时交换两个空间，继续进行内存分配。这地方采用的是mark-copy算法

老生代主要采用的是mark-compack和mark-sweep算法，因为mark-sweep会在GC时产生内存碎片，所有使用mark-compack去整理内存，将活着的对象移动到另一端，最后清除到边界外的另一端，因为mark-sweep比较快，在取舍上主要采用mark-sweep，在内存不足时采用mark-compack